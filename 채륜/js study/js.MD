# **자바스크립트 요약**
----------------------------------------------------------------------
### **표현식과 문장**

자바스크립트에서 값을 만들어내는 간단한 코드를 **표현식**이라고 한다.
하나 이상의 표현식이 모이면 **문장**이 된다.
자바스크립트에서 정해놓은 특별한 의미가 있는 단어를 **키워드**라고 한다.
**식별자**는 주로 변수명이나 함수명으로 사용된다.
> **주석**은 프로그램 코드를 설명할 때 쓰인다. 진행에는 영향을 주지 않는다.
> > // 형식으로 사용한다.

#### **출력** 
~경고창~에 출력하는 방법은 ~alert()함수~ 사용한다.
~콘솔~에 출력하는 방법은 ~console.log()메소드~를 사용한다.

### **자료와 변수**

프로그래밍에서 프로그램이 처리할 수 있는 모든 것을 **자료**라고 부른다.
이를 형태에 따라 나눠 놓은 것을 **자료형**이라고 한다.

다양한 종류의 자료형을 제공하는데 가장 기본적이고 많이 사용하는 것
+ 숫자
+ 문자열
+ 불 (boolean)

#### **문자열 자료형**
alert()함수 또는 console.log()메소드의 매개변수를 입력하는 것과 같은 문자들의 집합을 **문자열**이라고 한다.
자바스크립트에서는 문자가 하나든 여러 개든 모두 **문자열 자료형**이라고 한다.

> 함수와 메소드는 특정 기능을 동작시키도록 작성된 코드의 집합이다.

> **이스케이프 문자**는 아래와 같은 기능을 갖는다.
> > 1. \n: 줄바꿈
> > 2. \t: 탭
> > 3. 이스케이프 문자 x2 : 역슬래시 그 자체를 의미한다.

#### **문자열 연산자**

- "문자열 + 문자열" 에서 '+'는 **문자열 연결 연산자** 라고 불리운다.

- 문자열[숫자]
- - 자열 내부의 문자 하나를 선택할 때는 **문자 선택 연산자**를 사용한다.
- -  > 문자열 뒤에 대괄호를 입력하고 괄호 안에 선택할 문자의 위치를 숫자로 지정한다. 이때 위치를 나타내는 숫자를 **인덱스**라고 부른다.

문자열 내부의 문자 개수를 **문자열 길이**라고 표현한다. 
- length속성을 사용한다.

#### **숫자 자료형**
- 사칙 연산자를 사용가능(+, -, *, /)
- 나머지 연산자(%)로 나머지 연산도 가능

#### **불 자료형**

자바스크립트에서는 참과 거짓 값을 표현할 때 **불 자료형**을 사용한다.
true와 false 2가지로 나뉜다. 간단하게 2가지만 입력하면 불을 만들 수 있음

> 비교 연산자
> > === : 양쪽이 같다.
> > !== : 양쪽이 다르다.

__불부정 연산자__

1. 논리 부정 연산자 !는 참을 거짓으로, 거짓을 참으로 바꾼다.
2. 논리곱 연산자 &&는 양쪽 변의 모두 값이 true일때만 true로 결과를 내고 나머지는 다 false이다.
3. 논리합 연산자 ||는 양쪽 변의 값 중 하나만 true여도 true를 결과로 낸다.


#### **자료형 검사**

숫자, 문자열, 불 같은 자료형을 확인할 때는 typeof 연산자를 사용한다. (단항 연산자이다.)
===연산자와 !==연산자는 **값과 자료형**이 같은지를 비교한다.
==연산자와 !=연산자는 **값**이 같은지를 비교하는 연산자이다.


여기서 말하는 단항 연산자는 피연산자의 개수에 때라 **단항, 이항, 삼항연산자**로 나뉜다.

### 상수와 변수

상수는 '항상 같은 수'라는 의미를 가지고, 값에 이름을 한 번 붙이면 값을 수정할 수 없다.
변수는 '변할 수 있는 수'로 값을 수정할 수 있다.

상수를 만드는 과정을 선언이라고 표현하고, const 키워드로 선언한다.
변수를 만들 때는 let 키워드를 사용한다.

> 변수에 적용할 수 있는 연산자
> > += : 기존 변수의 값에 값을 더한다.
> > -= : 기존 변수의 값에 값을 뺀다.
> > *= : 기존 변수의 값에 값을 곱한다.
> > /= : 기존 변수의 값에 값을 나눈다.
> > %= : 기존 변수의 값에 나머지를 구한다.

**증강 연산자**

- 변수++ : 기존의 변수 값에 1을 더한다(후위).
- ++변수 : 기존의 변수 값에 1을 더한다(전위).
- 변수-- : 기존의 변수 값에 1을 뺀다(후위). 
- --변수 : 기존의 변수 값에 1을 뺀다(전위).

여기서 말하는 **전위**는 문장을 실행하기 전에 값을 더하는 것을 말한다.
반대로, 후위는 실행하고 나서 값을 더하는 것을 뜻한다.

#### undefined 자료형

상수와 변수를 사용하면 undefined 자료형을 확인할 수 있다.

1. 상수와 변수로 선언하지 않은 식별자
1. 값이 없는 변수

### 자료형 변환

#### 문자열 입력

- 문자열 자료형을 입력할 때 사용하는 함수는 prompt()이다. (메시지 문자열, 기본 입력 문자열)

- 문자열 외에 불 자료형도 값으로 입력받을 수 있다. 이때는 confirm()함수를 사용한다. (메시지 문자열)

- 다음 자료형을 숫자 자료형으로 변화낳ㄹ 때는 Number()함수를 사용한다.
> 다른 문자가 들어있어서 숫자로 변환할 수 없는 문자열의 경우 NaN이라는 값을 출력한다.

- 다른 자료형을 문자열 자료형으로 변환할 때는 String()함수를 사용한다.

- 다른 자료형을 불 자료ㅇ으로 변환할 때는 Boolean()함수를 사용한다.

----------------------------------------------------------------------------
### **조건문**

#### **if 조건문**

- if 조건문은 조건에 따라서 코드를 실행하거나 실행하지 않을 때 사용하는 구문이다.

- 이때의 조건은 불 자료형을 의미한다. (비교 연산자와 논리 연산자를 활용해 조건을 만듦.)

- else 구문은 if 조건문 바로 뒤에 붙여서 사용한다. 이를 조합한 조건문을 if else 조건문이라 부른다.

- 중첩 조건문은 else if를 이용한다.


#### **switch 조건문과 짧은 조건문**

- switch 조건문의 괄호 안에는 비교할 값을 입력하고, 만약 입력한 표현식과 case 키워드 옆의 표현식이 같다면 case 키워드 바로 다음에 오는 문장을 실행한다.
> break는 switch 조건문을 나가기 위해서 사용한다.

**조건부 연산자**

- 불 표현식 ? 참일 때의 결과 : 거짓일 때의 결과
- 위와 같은 형식이 조건부 연산자이고, 3개의 항을 갖기 때문에 삼항 연산자라고 부르기도 한다.

**짧은 조건문**

- 짧은 조건문은 논리 연산자의 특성을 조건문으로 사용하는 것입니다. (잘 사용하지는 않는다 함.)

-----------------------------------------------------------------

### **반복문**

#### **배열**

- 배열은 여러 자료를 묶어서 활용할 수 있는 특수한 자료이다.
> 배열을 만드는 법은 대괄호를 사용해 생성하고, 내부의 값을 쉼표로 구분해 입력한다.
> 배열 내부에 들어 있는 값을 요소라고 한다. (어떠한 종류의 자료형도 가능)

- 자바스크립트는 가장 앞에 있는 요소를 0번째로 표현한다.
> 이때 요소 순서를 인덱스라고 부른다. (배열[인덱스])

- 배열 내부에 들어 있는 요소의 개수를 확인할 때는 length속성을 사용한다.
> 배열.length

- 배열 뒷부분에 요소를 추가하려면 push()메소드를 사용한다.
> 배열.push(요소)

- **배열 요소를 제거하는 방법**
1. 인덱스를 기반으로 제거하는 경우
2. 값을 기반으로 제거하는 경우

> _인덱스로 요소 제거하기_
> > splice()메소드를 사용해 특정 인덱스에 있는 요소를 제거한다.
> > 배열.splice(인덱스, 제거할 요소의 개수)

> _값으로 요소 제거하기_
> > indexOf()메소드를 사용해 값의 위치를 추출한 뒤 splice()메소드를 사용해 제거한다.
> > 1. const 인덱스 = 배열.indexOf(요소)
> > 2. 배열.splice(인덱스, 1)
> > > indexOf()메소드는 배열 내부에 요소가 있을 경우 인덱스를 리턴. 하지만 배열 내부에 요소가 없을 때는 -1을 리턴한다.

- _배열의 특정 위치에 요소 추가하기_
> splice()메소드의 2번째 매개변수에 0을 입력하면 아무 것도 제거하지 않고, 3번째 매개변수에 추가하고 싶은 요소를 입력한다.
> > 배열.splice(인덱스, 0, 요소)

- 자료의 비파괴와 파괴
- - 비파괴적 처리: 처리 후에 원본 내용이 변경되지 않는다.
- - 파괴적 처리: 처리 후에 원본 내용이 변경된다.

#### **for in 반복문**

- 배열과 함께 사용할 수 있는 반복문, 배열 요소를 하나하나 꺼내서 특정 문장을 실행될 때 사용한다.
> 기본 형태: for(const 반복 변수 in 배열 또는 객체){ 문장 }

#### **for of 반복문**

- 요소의 값을 반복할 때 안정적으로 사용할 수 있다.
> 기본 형태: for(const 반복 변수 of 배열 또는 객체){ 문장 } 

#### **for 반복문**

- for 반복문은 특정 횟수만큼 반복하고 싶을 때 사용하는 범용적인 반복문이다.
> 기본 형태: for(let i = 0; i < 반복 횟수; i++){ 문장 }
> > 배열과 함께 사용하기: 보통 배열의 length 속성만큼 반복을 돌리는 형태로 사용한다.
> > for(let i = 0; i < 배열.length; i++){ consol.log('${i}, $배열{i}) }

#### **while 반복문**

- if 조건문과 다르게 불 표현식이 true면 계속해서 문장을 실행한다.
> while(불 표현식){ 문장 }

#### **break 키워드**

- switch 조건문이나 반복문을 벗어날 때 사용하는 키워드이다.

-------------------------------------------

### **함수**

#### **함수의 기본 형태**

- 함수를 사용하는 것을 함수 호출이라 하고, 괄호 내부에 넣는 자료를 매개변수라고 부른다. 호출해서 나오는 결과를 리턴값이라 한다.

- 함수는 코드의 집합을 나타내는 자료형이다.
> 기본 형태 : function() {}
> > + 반복 작업을 피할 수 있음.
> > + 전체 코드의 가독성이 좋아짐.
> > + 기능별로 수정이 가능하므로 유지보수가 쉬워짐.

- 이름이 붙어있지 않은 함수 = 익명 함수

- 이름이 있는 함수 = 선언적 함수

- 가변 매개변수 함수 : 호출 시 매개변수의 개수가 고정적이지 않은 함수

- 자바스크립트에서 이러한 함수를 구현할 때 나머지 매개변수라는 문법을 사용한다.
> function 함수 이름 (...나머지 매개변수) {}
> 함수의 매개변수 앞에 마침표 3개를 입력하면 매개변수들이 배열로 들어온다.

- 들어온 자료형을 확인하는 법은 'typeof 연산자'를 사용한다. ex: 배열에 사용하면 object라는 결과가 나온다.
> 정확하게 확인하려면 Array.isArray() 메소드를 활용해야 한다.

- 전개 연산자 : 배열을 전개해서 함수의 매개변수로 전달해준다
> 함수 이름(...배열)

- 기본 매개변수 : 매개변수에 기본값을 지정한다.
> 함수 이름(매개변수, 매개변수 = 기본값, 매개변수 = 기본값)

#### **함수 고급**

- 콜백함수 : 매개변수로 전달하는 함수이다.
- 콜백함수를 활용하는 가장 기본적인 함수는 forEach() 메소드이다.
> function(value, index, array) { }

- map(), filter()메소드도 배열이 갖고있는 함수이다.

- 화살표 함수는 function 키워드 대신 화살표를 사용한다.
> (매개변수) => { }
> > (매개변수) => 리턴값

- 타이머 함수
> * setTimeout(함수, 시간) : 특정시간 후에 함수를 한 번 호출한다.
> * setInterval(함수, 시간) : 특정 시간마다 함수를 호출한다.

- 함수 즉시 호출 : (function() { })()

> - 익명 함수는 순차적인 코드 실행에서 코드가 해당 줄을 읽을 때 생성된다.
> - 선언적 함수는 순차적인 코드 실행이 일어나기 전에 생성된다.

------------------------------------------------

### **객체**

#### **객체의 기본**

- 객체는 실제로 존재하는 사물을 의미하고 이름과 값으로 구성된 속성을 가진 자바스크립트의 기본 데이터 타입이다.

- 배열은 객체를 기반으로 만들어져서 객체와 상당히 비슷하다. 하지만, 객체는 키를 사용한다는 것에서 다르다.
> 키: 값

#### **속성과 메소드**

- 배열 내부의 있는 값은 요소라고 부르고, 객체의 내부에 있는 값은 속성이라고 한다.

- 객체의 속성 중 함수 자료형인 속성을 메소드라고 부른다.

- 자기 자신이 가진 속성을 표시할 때는 this 키워드를 사용한다.

**동적으로 객체 속성 제거하기**
- 객체의 속성을 제거할 때는 delete 키워드를 사용한다.
> 기본 형태 : delete 객체.속성

#### **객체의 속성과 메소드 사용하기**

- 자바스크립트에서 사용하는 자료는 크게 기본 자료형과 객체 자료형으로 구분할 수 있다.
> 기본 자료형 : 숫자, 문자열, 불
> 객체 자료형 : 함수, 배열, ...이외 전부

- 기본 자료형이 객체 자료형이 될 수 있다.

- 함수는 객체의 특성을 완벽하게 가지고 있으므로 일급 객체에 속한다고 표현한다.
> typeof b의 결과는 "funtion"이 나온다.

#### **기본 자료형을 객체로 선언하기**

> const 객체 = new 객체 자료형 이름()

> 이렇게 하면 숫자 객체, 문자열 객체, 불 객체를 생성할 수 있다.

#### **프로토타입으로 메소드 추가하기**

- 어떤 객체의 prototype이라는 속성이 객체 전용 틀이라고 할 수 있다.
> prototype 객체에 속성과 메소드를 추가하면 모든 객체에서 해당 속성과 메소드를 사용할 수 있다.
> > 객체 자료형 이름.prototype.메소드이름 = funtion() { }

- 객체 내부에서 값을 꺼내 쓰는 것임을 명확하게 하기 위해서 valueOf() 메소드를 사용하는 것이 일반적이다.

- 문자열 내부에 어떤 문자열이 있는지, 배열 내부에 어떤 자료가 있는지 확인할 때는 indexOf() 메소드를 사용한다.

**Number객체**

- Number 객체에서 자주 사용하는 메소드는 toFixed()메소드이다.

- 무한대 숫자는 양의 무한대 숫자와 음의 무한대 숫자로 나뉜다. 
- isFinite() 메소드가 false인 경우 양의 무한대 숫자와 음의 무한대 숫자 2가지 경우이다.

**String 객체**

- 사용자의 실수 또는 악의적인 목적으로 문자열 앞뒤에 공백이 추가되는 경우를 제거하는 것이 trim() 메소드다.

- split() 메소드는 문자열을 매개변수로 잘라서 배열을 만들어 리턴한다.

**JSON 객체**

- JavaScript Object Notation의 약자로 자바스크립트의 객체처럼 자료를 표현하는 방식이다.

- 규칙은 아래와 같다.
> * 값을 표현할 때는 문자열, 숫자, 불 자료형만 사용할 수 있다.(함수 등은 사용 불가)
> * 문자열은 반드시 큰따옴표로 만들어야 한다.
> * 키에도 반드시 따옴표를 붙여야 한다.

- 자바스크립트 객체를 JSON 문자열로 변환할 때는 JSON.stringify() 메소드를 사용한다.

- JSON 문자열을 자바스크립트 객체로 전개할 때는 JSON.parse() 메소드를 사용한다.

**Math 객체**

- 수학과 관련된 기본적인 연산을 할 때는 Math객체를 사용한다.

- 랜덤한 숫자를 생성할 때는 Math.random() 메소드를 사용한다.
> 0이상 1미만의 랜덤한 숫자를 생성한다.

----------------------------------------------

### **객체와 배열 고급**

- 배열 기반의 다중 할당
> [식별자, 식별자, 식별자, ...] = 배열

- 객체 기반의 다중 할당
> {속성 이름, 속성 이름} = 객체
> {식별자 = 속성 이름, 식별자 = 속성 이름} = 객체

- 배열 전개 연산자
> - 배열과 객체는 할당할 때 얕은 복사가 이루어진다.
> > - 다른 이름이 붙을 뿐인 것

> - 깊은 복사는 두 배열이 완전히 독립적으로 작동함.
> > - 전개 연산자를 사용한 배열 복사 : [...배열]
> > - 배열 요소 추가 : [...배열, 자료, 자료, 자료]

> - 전개 연산자를 사용한 객체 복사 : {...객체}
> - 객체 요소 추가 : {...객체, 자료, 자료, 자료}

-------------------------------------------------

### **문서 객체 조작하기**

- html, head, body, h1, span 등을 HTML에서는 요소라고 하고, 자바스크립트에서는 이를 문서 객체라고 한다.
> 문서 객체를 조합해서 만든 전체적인 형태를 문서 객체 모델이라고 한다.

#### **DOMContentLoaded 이벤트**

- 문서 객체를 조작할 때 사용한다. (웹 브라우저가 문서 객체를 모두 읽고 나서 실행하는 이벤트)
> document.addEventLisner('DOMContentLoaded', () => { 문장 })
> > 오탈자를 입력해도 오류를 발생하지 않음 주의.

#### **문서 객체 가져오기**

- document.요소, document.querySelector(선택자)
> 선택자의 종류 : 태그, 아이디(#아이다), 클래스(.클래스), 속성 선택자([속성 = 값]), 후손 선택자(선택자 A 아래에 있는 선택자 B를 선택) 

- querySelector() : 요소를 하나만 추출

- querySelectorAll() : 문서 객체를 여러 개 추출
> 일반적으로 forEach() 메소드를 사용해서 반복을 돌림

#### **글자 조작하기**

- 문서 객체.textContent : 입력된 문자열을 그대로 넣는다.
- 문서 객체.innerHTML : 입력된 문자열을 HTML 형식으로 넣습니다

#### **속성 조작하기**

- 문서 객체.setAttribute(속성 이름, 값) : 특성 속성에 값을 지정
- 문서 객체.getAttribute(속성 이름) : 특정 속성을 추출

#### **문서 객체 생성하기**

- document.createElement() 메소드를 사용한다.
> document.createElement(문서 객체 이름)

- 문서 객체에는 appedChild() 메소드가 있으며, 어떤 부모 객체 아래에 자식 객체를 추가할 수 있다.
> 부모 객체.appendchild(자식 객체)

#### **문서 객체 제거하기**

- removeChild() 메소드를 사용한다.
> 부모 객체.removeChild(자식 객체)

- 일반적으로 어떤 문서 객체를 제거할 때
> 문서 객체.parentNode.removeChild(문서 객체)

#### **이벤트 설정하기**

- 모든 문서 객체는 생성되거나 클릭, 마우스를 위에 올렸을 때 이벤트가 발생한다. 이 이벤트가 발생할 때 실행할 함수 addEventListener()
> 문서 객체.addEventListener(이벤트 이름, 콜백 함수)

- 제거할 때는 removeEventListener() 메소드를 사용한다.
> 문서 객체.removeEventListener(이벤트 이름, 이벤트 리스너)

### **이벤트 활용**

#### **이벤트 모델**

- 이벤트를 연결하는 방법을 이벤트 모델이라 한다.
- - 표준 이벤트 모델 (addEventListener())
> document.body.addEventListener('keyup', () => {   })

- - 고전 이벤트 모델 (onxxx)
> document.body.onkeyup = (event) => {  }

- - 인라인 이벤트 모델 (onxxx으로 시작하는 속성을 HTML 요소에 직접 넣어서 이벤트 연결)
> <script> 
> const listener = (event) => {   }
> </script>
> <body onkeyup="listener(event)">
> </body>

- 모든 이벤트 모델의 이벤트 리스너는 첫 번째 매개변수로 **이벤트 객체**를 받습니다.

#### **기본 이벤트 막기**
- preventDefault() 메소드를 사용

### **예외 처리**

- 코드가 실행조차 되지 않는 오류 : 구문 오류
- 코드 실행 중간에 발생하는 오류 : 예외
> 이를 처리하는 것 : 예외 처리

#### **오류의 종류**

- 프로그램 실행 전에 발생하는 오류
> 구문 오류

- 프로그램 실행 중에 발생하는 오류
> 예외 또는 런타임 오류

#### **고급 예외 처리**

- 예외를 조금 더 쉽게 잡을 수 있는 기능 : try catch finally 구문
> try { 예외가 발생할 가능성이 있는 코드}
> catch (exeption) {예외가 발생했을 때 실행할 코드}
> finally {무조건 실행할 코드}

### **예외 처리 고급**

- 예외가 발생하면 발생된 정보를 확인할 수 있게 해주는 **예외 객체**

#### **예외 객체**

- try catch 구문을 사용할 때 catch 괄호 안에 입력하는 식별자 (일반적으로 e나 exception 사용)
> **예외 객체의 속성** 
> 속성 이름 : 설명
> name : 예외 이름
> message : 예외 메시지

#### **예외 강제 발생**

- 예외를 강제로 발생시킬 때는 throw 키워드를 사용한다.
> throw 문자열 // 단순하게 예외를 발생시킴
> throw new Error(문자열) // 조금 더 자세하게 예외를 발생시킴

### **클래스**

- 클래스는 객체를 효율적이고 안전하게 만들기 위해서 만들어진 문법이다.

#### **클래스 선언하기**

- 객체들을 정의하고 그러한 객체를 활용해서 프로그램을 만드는 것을 객체 지향 프로그래밍이라고 한다.
- - 클래스와 프로토타입이라는 2가지 문법을 통해 객체를 효율적으로 만들 수 있게 했다.
> - 클래스 생성
> class 클래스 이름 {   }
> > 클래스를 기반으로 만든 객체는 전문 용어로 인스턴스라고 한다. 그냥 객체로 부르는 경우도 많다.
> > - 인스턴스 생성시
> > - - new 클래스 이름()

#### **생성자**

- 객체가 생성될 때 호출되는 생성자
> class 클래스 이름 {
>    constructor(){
>       생성자 코드  } }

### **클래스의 고급 기능**

- 상속은 어떤 클래스가 가지고 있는 속성과 메소드를 다른 클래스에게 물려주는 형태로 사용한다.
> - 유산을 주는 클래스를 부모 클래스
> - 유산을 받는 클래스를 자식 클래스

#### **private 속성과 메소드**

- 외부 클래스에서의 접근을 막는다  (private 또는 #을 사용)
> class 클래스 이름 {
>    #속성 이름 
>    #메소드 이름(){  } }

#### **게터와 세터**

- getxx : 속성 값을 확인할 때 사용하는 메소드
- setxx : 속성 값을 지정할 때 사용하는 메소드
> class 클래스 이름{
>    get 이름 () {return 값}
>    set 이름 (value) {  } }

#### **static 속성과 메소드**

- 인스턴스를 만들지 않고 사용할 수 있는 속성과 메소드
> 클래스 이름.속성
> 클래스 이름.메소드()

#### **오버라이드**

- 부모가 갖고 있는 함수를 자식에서 다시 선언해서 덮어쓰는 것

-------------------------------------------------------------------------------------------

### **DOM**

- **Document Object Model**
> - 텍스트 파일로 만들어져 있는 웹 문서를 브라우저에 랜더링하려면 웹 문서를 브라우저가 이해할 수 있는 구조로 메모리에 올려야한다.
> - 브라우저의 렌더링 엔진은 웹 문서를 로드한 후, 파싱하여 웹 문서를 브라우저가 이해할 수 있는 구조로 구성하여 메모리에 적재하는데 이를 DOM이라 한다.
> - 모든 요소와 요소의 어트리뷰트, 텍스트를 각각의 객체로 만들고 부자 관계를 표현할 수 있는 트리 구조로 구성한 것.

- HTML 문서에 대한 모델 구성
> 브라우저는 HTML 문서를 로드한 후 해당 문서에 대한 모델을 메모리에 생성, 이때 객체의 트리로 구성되는데 이것을 DOM tree라 한다.

- HTML 문서 내의 각 요소에 접근 / 수정
> DOM은 모델 내의 각 개체에 접근하고 수정할 수 있는 프로퍼티와 메소드를 제공, DOM이 수정되면 브라우저를 통해 변경됨

### **DOM tree**

- 문서 노드
> 트리의 최상위에 존재하며, 각각 노드에 접근하려면 문서 노드를 통해야 하낟. (DOM tree에 접근하기 위한 시작점)

- 요소 노드
> HTML 요소를 표현한다. 중첩에 의해 부자 관계를 가지고, 이를 통해 정보를 구조화 한다. (요소 노드는 문서의 구조를 서술)
> 어트리뷰트, 텍스트 노드에 접근하려면 요소 노드를 찾아 접근해야함. (요소별 특성을 표현하기 위해 HTMLElement 객체를 상속한 객체로 구성)

- 어트리뷰트 노드
> HTML 요소의 어트리뷰트를 표현한다. 어트리뷰트 노드는 해당 어트리뷰트가 지정된 요소의 자식이 아니라 해당 요소의 일부로 표현
> 해당 요소 노드를 찾아 접근하면 어트리뷰트를 참조, 수정할 수 있다.

- 텍스트 노드
> HTML 요소의 텍스트를 표현한다. 요소 노드의 자식이며 자신의 자식 노드를 가질 수 없다. (DOM tree의 최종단)

### **DOM Query / Traversing (요소에의 접근)

#### **하나의 요소 노드 선택(DOM Query)

- **document.getElementById(id)**
> - id 어트리뷰트 값으로 요소 노드를 한 개 선택한다. 복수개가 선택된 경우, 첫번째 요소만 반환
> - Return: HTMLElement를 상속받은 객체
> - 모든 브라우저에서 동작

- **document.querySelector(cssSelector)**
> - CSS 셀렉터를 사용하여 요소 노드를 한 개 선택한다. 복수개가 선택된 경우, 첫번째 요소만 반환
> - Return: HTMLElement를 상속받은 객체
> - IE8 이상의 브라우저에서 동작

#### **여러 개의 요소 노드 선택(DOM Query)

- **document.getElementByClassName(class)**
> - class 어트리뷰트 값으로 요소 노드를 모두 선택한다. 공백으로 구분하여 여러 개의 class를 지정할 수 있다.
> - Return: HTMLCollection(live)
> - IE9 이상의 브라우저에서 동작

- **document.getElementsBYTagName(tagName)
> - 태그명으로 요소 노드를 모두 선택
> - Return: HTMLCollection(live)
> - 모든 브라우저에서 동작

#### **DOM Traversing(탐색)

- **parentNode**
> - 부모 노드를 탐색한다.
> - Return: HTMLElement를 상속받은 객체
> - 모든 브라우저에서 동작

- **firstChild, lastChild**
> - 자식 노드를 탐색한다.
> - Return: HTMLElement를 상속받은 객체
> - IDE9 이상의 브라우저에서 동작

### **DOM Manipulation**

#### **텍스트 노드에의 접근/수정**

- 요소의 텍스트는 텍스트 노드에 저장되어 있다. 텍스트 노드에 접근하려면 아래와 같은 수순이 필요하다.
> 1. 해당 텍스트 노드의 부모 노드를 선택한다.
> 2. firstChild 프로퍼티를 사용하여 텍스트 노드를 탐색한다.
> 3. 텍스트 노드의 유일한 프로퍼티(nodeValue)를 이용하여 텍스트를 취득한다.
> 4. nodeValue를 이용하여 텍스트를 수정한다.

- **nodeValue**
> - 노드의 값을 반환한다.
> - Return: 텍스트 노드의 경우는 문자열, 요소 노드의 경우 null 반환
> - IE6 이상의 브라우저에서 동작한다.

#### **어트리뷰트 노드에의 접근/수정**

- **className**
> - class 어트리뷰트의 값을 취득 또는 변경한다. className 프로퍼티에 값을 할당하는 경우, class 어트리뷰트가 존재하지 않으면 class 어트리뷰트를 생성하고 지정된 값을 설정한다. 값이 여러 개일 경우, 공백으로 구분된 문자열이 반환되므로 Stirng 메소드 split(' ')를 사용하여 배열로 변경 후 사용
> - 모든 브라우저에서 동작한다.

#### **HTML 콘텐츠 조작(Maniplation)**

- 마크업이 포함된 콘텐츠를 추가하는 행위는 크로스 스크립팅 공격에 취약하다

- **textContent**
> - 요소의 텍스트 콘텐츠 취득 또는 변경, 이때 마크업은 무시된다. textContent를 통해 요소에 새로운 텍스트를 할당하면 텍스트 변경 가능.
> - IE9 이상의 브라우저에서 동작한다.

#### **DOM 조작 방식**

- 한 개의 요소를 추가하는 경우 사용한다. 다음의 수순에 따라 진행한다.
> 1. 요소 노드 생성 createElement()메소드를 사용하여 새로운 요소 노드를 생성한다. 인자로 태그 이름을 전달한다.
> 2. 텍스트 노드 생성 createTextNode()메소드를 사용하여 새로운 텍스트 노드를 생성한다. 경우에 따라 생략될 수 있지만 생략하는 경우, 콘텐츠가 비어있는 요소가 된다.
> 3. 생성된 요소를 DOM에 추가 appendChild()메소드를 사용하여 생성된 노드를 DOM tree에 추가한다. 또는 removeChile()메소드를 사용하여 DOM tree에서 노드를 삭제할 수도 있다.

#### **insertAdjacentHTML()**

- **insetAdgjacentHTML(position, string)**
> - 인자로 전달한 텍스트를 HTML로 파싱하고 그 결과로 생성된 노드를 DOM 트리의 지정된 위치에 삽입. 첫번째 인자는 삽입 위치, 두번째 인자는 삽입할 요소를 표현한 문자열
> - 모든 브라우저에서 동작한다.